Prim =>  O(n^2)  用矩阵做
    任取点v(当成一棵树)
      取与树相邻的未访问的结点间权最小的边，将该边和该顶点并入 (重复n-1次，直到所有点被并入)

    tips ：
      lowcost[] 记录树到其他结点间最小边的权值，每次并入w后，都更新这个矩阵。即：如果
      weight(w,i) < lowcost[i]，就更新一下


Kruskal => 时间复杂度取决于边排序
    所有边按权值排序
       检查所有边，每次并入不构成回路的边

    tips :
      并查集 disjointSet
         struct Road {
           int a,b;       //一条边上的两个顶点
           int weight;
         };
         并查集初始 =>  (假设9个顶点)
            下标： 0  1  2  3  4  5  6  7  8    结点
              值： 0  1  2  3  4  5  6  7  8    相应的父结点
            disjointSet[i] = i  表明i是根结点