！！！树的问题多考虑递归解决！！！

树的基本常识：

 1.层，高度，深度
   层：根结点位于第0层。
      结点的层次：从结点到根结点的路径中边的条数
   深度：结点最大层次
   高度：从一个结点出发，一直到它的叶子结点的最大路径中的边的条数
      叶子结点的高度认为是0
      树的高度就是根结点的高度

 2.度
   结点的度：结点分支的个数
   树的度：所有结点中最大的度
   叶子结点：度为0的结点

 3.树的存储结构
     摘自：https://blog.csdn.net/smile_from_2015/article/details/63687696
     1）树的双亲存储结构
         每个结点除了知道自己是谁以外，还知道它的父亲在哪里
             node： data, parent
       数组表示：
       下标：结点  0  1  2  3  4  5  6  7
       值：父节点    -1  1  1  1  3  3  3

                    1
                   /｜\
                  2 3 4
                   /｜\
                  5 6 7

     2).树的孩子存储结构能（图的邻接链表）
        把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。
        然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中

     3).孩子兄弟表示法 (这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树)
        node:  data, first_child, right_sib
        森林 => 二叉树
          a) 先将树转为"二叉树的孩子兄弟表示法"
          b）根结点无右孩子，用来把各个树的根结点串起来

 4.二叉树的性质
   1）分支和结点的度：
      a) 除了根结点，其他结点都和分支一一对应：即 分支数 = n0 + n1 + n2 - 1 = n1 + 2n2
         => n0 = n2 + 1
      b) 求n个结点的二叉树的空指针数
         空指针数：2n0 + n1 = n + 1
         n = n0 + n1 + n2 = 2n0 + n1 - 1

   2) 结点数量：
      第i层最多： 2^i 个结点
      深度为k的二叉树最多： 2^(i+1) - 1 个结点

 5.树和森林的遍历：
      树的遍历： 先序 => 根，每个子树；  后序 => 每个子树，根；
   对应的二叉树: 先序                  中序

    森林的遍历： 先序 和 中序

 6.关于赫夫曼树
   赫夫曼树 => https://blog.csdn.net/wuxudong12138/article/details/100032443
   赫夫曼编码 => https://baijiahao.baidu.com/s?id=1651316704300729180&wfr=spider&for=pc
   路径长度：两个结点间分支数
       树的路径长度：根到每个结点路径长度之和
   结点的带权路径长度：(根->该结点)路径长度 x 结点权值
   树的带权路径长度(WPL)：所有叶子结点的带权路径长度之和

线索二叉树
   // 代码见 tree-graph/thread_binary_tree
   struct TBTNode {
     int val;               // ltag: 为0时，left指向左子；为1时，left指向前驱
     int ltag, rtag;        // rtag: 为0时，right指向右子；为1时，right指向后继
     TBTNode *left;         // 可分为先序、中序、后序线索二叉树
     TBTNode *right;        // 先建立普通二叉树，再遍历修改指针（线索化）
     TBTNode(int x) : val(x), ltag(0), rtag(0), left(NULL), right(NULL) {}
   };

平衡二叉树（Balanced Binary Tree）
    空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
    https://www.cnblogs.com/zhangbaochong/p/5164994.html



判断二叉树是否对称 (这种问题多画几层树就好)
                     1                                    1
               2           2                           2     2
           4      3     3      4                    2  _  2   _
        5    6               6    5
                   对称                                 不对称
   方案1：                                   方案2：层遍历
   L.val=R.val
   L.left.val=R.right.val
   L.right.val=R.left.val


完全二叉树
  根节点位于第0层， 根到最左下结点经过的路径长度即为最大层数h
  0 ≤ i < h 时，第 i 层包含2^i个结点
  若为满二叉树，结点数为2^(h+1) - 1
  非满二叉树，总节点个数一定在 [2^h, 2^(h+1) - 1)内

  求完全二叉树的结点数：
     => 任何结点的左子树或者右子树至少一个是满二叉树


二叉搜索树
  若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  它的左、右子树也分别为二叉排序树

  「C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树」，所以map、set的增删操作时间时间复杂度是logn
