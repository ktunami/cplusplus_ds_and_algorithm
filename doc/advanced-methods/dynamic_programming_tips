动态规划

=> Fibonacci数的例子
             prev  cur  next
   index  0    1    2    3    4    5    6    7
   val    0    1    1    2    3    5    8    13

   next = prev + cur
   prev = cur
   cur  = next

   写成矩阵形式： x(n) = A * x(n-1)

   |    cur   |      |0   1|      |prev|
   |          |  =   |     |  *   |    |
   |prev + cur|      |1   1|      |cur |

   即x(n) = A^n * x(0)
   有公式见 ： https://en.wikipedia.org/wiki/Fibonacci_number
   求解Fibonacci数时间复杂度可达 log(n)

=> 关于DP
  一个规模较大的问题（可以用两三个参数表示），通过若干规模较小的问题的结果来得到的
  问题的最优解可以从其子问题的最优解来进行构建
  各种状态转移方程：
    dp[i] = opt(dp[i-1])+1
    dp[i][j] = func(i,j,k) + opt(dp[i-1][k])
    dp[i][j] = opt(dp[i-1][j-1],dp[i-1][j])+arr[i][j]
    dp[i][j] = opt(dp[i-1][j] + xi, dp[i][j-1] + yj, ...)

  例1：leetcode 70 爬楼梯
    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢
    令 dp[n] 表示到达第 n 阶的方法总数, dp[n]=dp[n-1]+dp[n-2]

  例2：leetcode 53 最大子数组
  给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和
    eg.  [-2,1,-3,4,-1,2,1,-5,4] 的最大子数组为[4,-1,2,1]，其和为6
    最重要：定义状态
        最大子数组 <=> max{由nums[i]结尾的最大子数组}
        定义dp[i] 表示以 nums[i] 结尾的连续子数组的最大和.
           dp[i] = dp[i-1]+nums[i] , if (dp[i-1] >= 0)
           dp[i] = nums[i] , if (dp[i-1] < 0)
           即：dp[i]=max(nums[i], dp[i−1]+nums[i])

  例3：leetcode 300 最长递增子序列
  给一个整数数组 nums ，找到其中最长严格递增子序列的长度。
  子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
