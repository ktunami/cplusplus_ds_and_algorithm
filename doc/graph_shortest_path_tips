Dijkstra => 某顶点到其余各点的最短路径 (带权) 0(n^2)
           S(已找到最短路径的顶点)                T(剩余顶点)
 初始：              v0                          其余各点
                                          每次从这里选到v0最短的点vu，放入S中。
                                          然后修改v0到T中各点距离的最小值
   tips :
   dist[vi] : v0到vi最短路径长度
   path[vi] : v0到vi的上一跳
              更新：if(dist[vi] > dist[vu] + edge(vu,vi).weight) {
                       dist[vi] = dist[vu] + edge(vu,vi).weight
                       path[vi] = vu
                   }
   flag[vi] : 1表示vi已并入S, 为0表示vi在T中


Floyd => 求图中任意一对顶点间最短路径 (带权)
   矩阵A (已知当前两点间最短路径，初始为权重)               矩阵Path (中间顶点,初始为-1)
      for(int k{0}; k < vex_num; ++k) {
         if (A[i][j] > A[i][k] + A[k][j]) {
            A[i][j] = A[i][k] + A[k][j];
            Path[i][j] = k;
         }
      }
   根据Path求路径：求a到b
      Path[a][b] = c
      那么答案变成了求a到c和c到b的路径，递归终止条件Path[a][b] = -1

